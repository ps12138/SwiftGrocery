//: [Previous](@previous)

import Foundation

var str = "Hello, playground"

//: [Next](@next)


// Swift 是⾃动管理内存的，
// 这也就是说，我们不再需要操⼼内存的申请和分配。
// 当我们通过初始化创建⼀个对象时，Swift 会替我们管理和分配内存。
// ⽽释放的原则遵循了⾃动引⽤计数 (ARC) 的规则：
// - 当⼀个对象没有引⽤的时候，其内存将会被⾃动回收。

// 这套机制从很⼤程度上简化了我们的编码，
// 我们只需要保证在合适的时候将引⽤置空 (⽐如超过作⽤域，或者⼿动设为 nil 等)，
// 就可以确保内存使⽤不出现问题。
// 但是，所有的⾃动引⽤计数机制都有⼀个从理论上⽆法绕过的限制，
// 那就是循环引⽤ (retain cycle) 的情况。

// Attributes
// 那么从表⾯的⾏为上来说 unowned 更像以前的 unsafe_unretained ，
// weak 就是以前的weak 。
// ⽤通俗的话说，就是 unowned 设置以后即使它原来引⽤的内容已经被释放了，
// 它仍然会保持对被已经释放了的对象的⼀个 "⽆效的" 引⽤，它不能是 Optional 值，也不会被指向 nil 。

// 如果你尝试调⽤这个引⽤的⽅法或者访问成员属性的话，程序就会崩溃。
// ⽽ weak 则友好⼀些，在引⽤的内容被释放后，标记为 weak 的成员将会⾃动地变成 nil (因此被标记为 @ weak 的变量⼀定需要是 Optional 值)。

// 关于两者使⽤的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，
// 尽量使⽤ unowned ，如果存在被释放的可能，那就选择⽤ weak 。